<?php
/**
 * PaymentCompleteHook class file.
 *
 * Registers and handles the WooCommerce “payment complete” hook. This class
 *  triggers background tasks to synchronize completed order data with Koban CRM:
 *   - Finding or creating a Koban “Third” for the customer
 *   - Generating an Invoice record in Koban
 *   - Creating a Payment record
 *   - Downloading the invoice PDF
 *   - Sending an email to the logistics team
 *
 * @package WooCommerceKobanSync
 */

namespace WCKoban\Hooks;

use WC;
use WC_Order;
use WCKoban\API;
use WCKoban\Logger;
use WCKoban\Serializers\InvoiceSerializer;
use WCKoban\Serializers\PaymentSerializer;
use WCKoban\Serializers\ThirdSerializer;
use WCKoban\Utils\MetaUtils;

/**
 * Class PaymentCompleteHook
 *
 * Registers a WooCommerce hook that triggers upon payment completion, then proceeds through
 * a series of steps to ensure the order and customer data are synced to Koban CRM.
 */
class PaymentCompleteHook {

	/**
	 * The number of retries allowed before definitive failure.
	 *
	 * @var int
	 */
	private static int $max_retries = 2;

	/**
	 * An instance of the Koban API client.
	 *
	 * @var API
	 */
	private $api;

	/**
	 * Adds a WooCommerce hook to detect when a user completes a payment.
	 */
	public function register(): void {
		// Execute flow in the background with WooCommerce ActionScheduler.
		add_action( 'woocommerce_payment_complete', array( $this, 'schedule_payment_complete' ) );
		add_action( 'wckoban_handle_payment_complete', array( $this, 'handle_payment_complete' ), 10, 3 );
	}

	/**
	 * Schedules a background action to process payment completion.
	 *
	 * @param int $order_id The WooCommerce order ID.
	 */
	public function schedule_payment_complete( int $order_id ): void {
		$workflow_id = uniqid( 'wkf_', true );

		Logger::debug( $workflow_id, "Scheduling background sync for order: {$order_id}" );

		as_enqueue_async_action(
			'wckoban_handle_payment_complete',
			array(
				'order_id'    => $order_id,
				'workflow_id' => $workflow_id,
				'attempt'     => 0,
			),
			'koban-sync'
		);
	}

	/**
	 * Called whenever a WooCommerce payment completes. Orchestrates the Koban sync steps:
	 *  - Checking order validity
	 *  - Finding or creating the associated Koban "Third"
	 *  - Generating invoice and payment records
	 *  - Retrieving Invoice PDF document
	 *  - Sending an Email to the Logistics team with the Invoice PDF and the Chronopost Label
	 *    (Generated by wc-multishipping plugin)
	 *
	 * @param int    $order_id The WC_Order ID.
	 * @param string $workflow_id The Workflow ID.
	 * @param int    $attempt The current retry number, 0 if initial attempt.
	 */
	public function handle_payment_complete( int $order_id, string $workflow_id, int $attempt ): void {
		Logger::debug(
			$workflow_id,
			'Detected payment complete',
			array( 'order_id' => $order_id )
		);

		$steps = array(
			array( $this, 'check_data_integrity' ),
			array( $this, 'find_koban_third_guid' ),
			array( $this, 'create_koban_invoice' ),
			array( $this, 'create_koban_payment' ),
			array( $this, 'get_koban_invoice_pdf' ),
			array( $this, 'send_email_to_logistics' ),
		);

		$order = wc_get_order( $order_id );
		$data  = array(
			'order'       => $order,
			'workflow_id' => $workflow_id,
		);

		if ( 0 !== $attempt ) {
			$data['koban_third_guid']   = MetaUtils::get_koban_third_guid( $order->get_user_id() );
			$data['koban_invoice_guid'] = MetaUtils::get_koban_invoice_guid( $order );
		}

		$failed_step = MetaUtils::get_koban_workflow_failed_step_for_order( $order );

		// Run the workflow through our state machine.
		$state     = new StateMachine( $steps, $data, $failed_step );
		$this->api = new API( $workflow_id );
		$state->process_steps();
		$this->handle_exit( $state, $attempt );
	}

	/**
	 * Ensures the order is valid and not already processed (i.e., no existing invoice).
	 *
	 * @param  StateMachine $state The workflow state manager.
	 * @return bool                True if valid or processed; false on error.
	 */
	public function check_data_integrity( StateMachine $state ): bool {
		$order = $state->get_data( 'order' );

		if ( ! $order instanceof WC_Order ) {
			return $state->failed(
				__( 'Invalid order.', 'woocommerce-koban-sync' ),
				false
			);
		}

		// Early termination if an invoice pdf already exists.
		if ( in_array( MetaUtils::get_koban_workflow_status_for_order( $order ), array( StateMachine::STATUS_SUCCESS, StateMachine::STATUS_STOP ) ) ) {
			return $state->stop(
				sprintf(
				/* translators: %d: the WooCommerce Order ID */
					__( 'Order #%d already processed.', 'woocommerce-koban-sync' ),
					$order->get_id()
				)
			);
		}

		// user_id 0 is Guest.
		$user_id = $order->get_user_id();
		if ( 0 !== $user_id && ! get_user_by( 'id', $user_id ) ) {
			return $state->failed(
				sprintf(
				/* translators: %d: the WooCommerce Customer ID */
					__( 'Invalid User ID : %d.', 'woocommerce-koban-sync' ),
					$order->get_user_id()
				),
				false
			);
		}
		return $state->success();
	}

	/**
	 * Finds or creates a Koban "Third" record associated with the order customer.
	 *
	 * @param  StateMachine $state The workflow state manager.
	 * @return bool                True on success, false on failure.
	 */
	public function find_koban_third_guid( StateMachine $state ): bool {
		$order   = $state->get_data( 'order' );
		$user_id = $order->get_user_id();

		// Check local user meta for an existing Koban GUID.
		if ( $user_id ) {
			$koban_third_guid = MetaUtils::get_koban_third_guid( $user_id );
			if ( $koban_third_guid ) {
				return $state->success(
					sprintf(
					/* translators: %s: the Koban Third GUID */
						__( 'Found Koban GUID in user metadata : %s.', 'woocommerce-koban-sync' ),
						$koban_third_guid
					),
					array( 'koban_third_guid' => $koban_third_guid )
				);
			}
		}

		// If not found in meta, query Koban by email.
		$koban_third_guid = $this->api->find_user_by_email( $order->get_billing_email() );
		if ( $koban_third_guid ) {
			if ( $user_id ) {
				MetaUtils::set_koban_third_guid( $user_id, $koban_third_guid );
			}
			return $state->success(
				sprintf(
				/* translators: %s: the Koban Third GUID */
					__( 'Found Koban Third with matching email: %s.', 'woocommerce-koban-sync' ),
					$koban_third_guid
				),
				array( 'koban_third_guid' => $koban_third_guid )
			);
		}

		// If no remote record, create one in Koban.
		$koban_third_guid = $this->create_koban_third( $order, $user_id );
		if ( $koban_third_guid ) {
			if ( $user_id ) {
				MetaUtils::set_koban_third_guid( $user_id, $koban_third_guid );
			}
			return $state->success(
				sprintf(
				/* translators: %s: the Koban Third GUID */
					__( 'Created Koban Third: %s.', 'woocommerce-koban-sync' ),
					$koban_third_guid
				),
				array( 'koban_third_guid' => $koban_third_guid )
			);
		}

		return $state->failed( __( 'Could not create Koban Third.', 'woocommerce-koban-sync' ) );
	}

	/**
	 * Helper to create a new Koban Third from WooCommerce order data.
	 *
	 * @param  WC_Order $order   The order object to extract user/billing info from.
	 * @param  int      $user_id The associated WordPress user ID, if any.
	 * @return string|null       The new Koban third GUID, or null on failure.
	 */
	public function create_koban_third( WC_Order $order, int $user_id ): ?string {
		$third_payload    = ( new ThirdSerializer() )->from_order( $order );
		$koban_third_guid = $this->api->upsert_user( $third_payload );

		return $koban_third_guid;
	}

	/**
	 * Creates a new invoice in Koban and stores its GUID in the order meta.
	 *
	 * @param  StateMachine $state The workflow state manager.
	 * @return bool                True on success, false on failure.
	 */
	public function create_koban_invoice( StateMachine $state ): bool {
		$koban_third_guid = $state->get_data( 'koban_third_guid' );
		$order            = $state->get_data( 'order' );

		$invoice_payload    = ( new InvoiceSerializer() )->from_order( $order, $koban_third_guid );
		$koban_invoice_guid = $this->api->create_invoice( $invoice_payload );

		if ( $koban_invoice_guid ) {
			MetaUtils::set_koban_invoice_guid_for_order( $order, $koban_invoice_guid );

			return $state->success(
				sprintf(
				/* translators: %s: the Koban Invoice GUID */
					__( 'Created Koban Invoice: %s.', 'woocommerce-koban-sync' ),
					$koban_invoice_guid
				),
				array( 'koban_invoice_guid' => $koban_invoice_guid )
			);
		}
		return $state->failed( __( 'Could not create Koban Invoice.', 'woocommerce-koban-sync' ) );
	}

	/**
	 * Creates a payment in Koban for the order's invoice, storing the result in the order meta.
	 *
	 * @param  StateMachine $state The workflow state manager.
	 * @return bool                True on success, false on failure.
	 */
	public function create_koban_payment( StateMachine $state ): bool {
		$koban_invoice_guid = $state->get_data( 'koban_invoice_guid' );
		$order              = $state->get_data( 'order' );

		$payment_payload    = ( new PaymentSerializer() )->from_order( $order, $koban_invoice_guid );
		$koban_payment_guid = $this->api->create_payment( $payment_payload );

		if ( $koban_payment_guid ) {
			MetaUtils::set_koban_payment_guid_for_order( $order, $koban_payment_guid );

			return $state->success(
				sprintf(
				/* translators: %s: the Koban Payment GUID */
					__( 'Created Koban Payment: %s.', 'woocommerce-koban-sync' ),
					$koban_payment_guid
				)
			);
		}
		return $state->failed( __( 'Could not create Koban Payment.', 'woocommerce-koban-sync' ) );
	}

	/**
	 * Retrieves the invoice PDF from Koban by its GUID, downloading it and storing the file path in order meta.
	 *
	 * @param  StateMachine $state The workflow state manager.
	 * @return bool                True on success, false on failure.
	 */
	public function get_koban_invoice_pdf( StateMachine $state ): bool {
		$koban_invoice_guid = $state->get_data( 'koban_invoice_guid' );
		$order              = $state->get_data( 'order' );

		$koban_invoice_pdf_path = $this->api->get_invoice_pdf( $koban_invoice_guid );
		if ( $koban_invoice_pdf_path ) {
			MetaUtils::set_koban_invoice_pdf_path_for_order( $order, $koban_invoice_pdf_path );

			return $state->success(
				sprintf(
				/* translators: %s: the Koban Invoice PDF path */
					__( 'Retrieved Koban Invoice PDF: %s.', 'woocommerce-koban-sync' ),
					$koban_invoice_pdf_path
				)
			);
		}
		return $state->failed( __( 'Could not retrieve Koban Invoice PDF.', 'woocommerce-koban-sync' ) );
	}

	/**
	 * Sends an email to the logistics department with invoice PDF + Chronopost label attachments.
	 *
	 * @param StateMachine $state The workflow state manager.
	 * @return bool True on success; false on failure.
	 */
	public function send_email_to_logistics( StateMachine $state ): bool {
		$order       = $state->get_data( 'order' );
		$workflow_id = $state->get_data( 'workflow_id' );

		$koban_invoice_pdf_path = MetaUtils::get_koban_invoice_pdf_path( $order );
		if ( ! file_exists( $koban_invoice_pdf_path ) ) {
			return $state->failed(
				sprintf(
				/* translators: %s: the Koban Invoice PDF path */
					__( 'Koban invoice PDF not found: %s.', 'woocommerce-koban-sync' ),
					$koban_invoice_pdf_path
				),
				false
			);
		}

		$shipping_data = $order->get_meta( '_wms_chronopost_shipment_data', true );
		if ( ! $shipping_data ) {
			return $state->failed( __( 'No shipping data found for this order.', 'woocommerce-koban-sync' ), false );
		}

		$tracking_number = $shipping_data['_wms_outward_parcels']['_wms_parcels'][0]['_wms_parcel_skybill_number'] ?? '';
		if ( ! $tracking_number ) {
			return $state->failed( __( 'No tracking number found in shipping data.', 'woocommerce-koban-sync' ), false );
		}

		$chronopost_label_path = WP_CONTENT_DIR . '/uploads/protected-pdfs/chronopost-label-' . $tracking_number . '.pdf';
		if ( ! file_exists( $chronopost_label_path ) ) {
			return $state->failed(
				sprintf(
				/* translators: %s: the Chronopost label PDF path */
					__( 'Chronopost label PDF not found: %s.', 'woocommerce-koban-sync' ),
					$chronopost_label_path
				),
				false
			);
		}

		// TODO: Check if enabled in WC Settings.
		$mailer = WC()->mailer()->get_emails();
		if ( isset( $mailer['wc_email_logistics'] ) ) {
			if ( $mailer['wc_email_logistics']->trigger( $order->get_id(), $koban_invoice_pdf_path, $chronopost_label_path ) ) {
				// TODO: Unlink after testing
				// unlink($chronopost_label_path);.
				return $state->success( __( 'Email sent to logistics.', 'woocommerce-koban-sync' ) );
			} else {
				return $state->failed( __( 'Could not send email to logistics.', 'woocommerce-koban-sync' ) );
			}
		}
		return $state->failed( __( 'wc_email_logistics not found in mailer.', 'woocommerce-koban-sync' ), false );
	}

	/**
	 * Handles the final state of the workflow, scheduling retries if necessary.
	 *
	 * @param StateMachine $state   The workflow state manager.
	 * @param int          $attempt The current attempt count.
	 */
	private function handle_exit( StateMachine $state, int $attempt ): void {
		$status = $state->get_status();
		$data   = $state->get_data();
		$order  = $data['order'];

		MetaUtils::set_koban_workflow_status_for_order( $order, $status );

		Logger::info(
			'exit',
			array(
				'status'  => $status,
				'retry'   => $state->retry,
				'attempt' => $attempt,
			)
		);
		if ( StateMachine::STATUS_FAILED === $status && $state->retry && $attempt < self::$max_retries ) {
			MetaUtils::set_koban_workflow_failed_step_for_order( $order, $state->failed_step );

			as_schedule_single_action(
				time() + 60,
				'wckoban_handle_payment_complete',
				array(
					'order_id'    => $order->get_id(),
					'workflow_id' => $data['workflow_id'],
					'attempt'     => $attempt + 1,
				),
				'koban-sync'
			);
		} else {
			MetaUtils::set_koban_workflow_failed_step_for_order( $order, null );
		}
	}
}
